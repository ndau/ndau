package backing

import (
	"fmt"
	"reflect"

	"github.com/attic-labs/noms/go/marshal"
	nt "github.com/attic-labs/noms/go/types"
	math "github.com/oneiro-ndev/ndaumath/pkg/types"
	util "github.com/oneiro-ndev/noms-util"
	"github.com/pkg/errors"
)

// this code generated by github.com/oneiro-ndev/generator/cmd/nomsify
// DO NOT EDIT

// Adding new fields to a nomsify-able struct:
//
// Managed vars are useful for adding new fields that are marshaled to noms only after they're
// first set, so that app hashes aren't affected until the new fields are actually needed.
//
// A managed vars map is a hash map whose keys are managed variable names.
// The `managedVars map[string]struct{}` field must be manually declared in the struct.
//
// Declare new fields using the "managedVar" prefix.  e.g. `managedVarSomething SomeType`.
// GetSomething() and SetSomething() are generated for public access to the new field.
//
// Once SetSomething() is called for the first time, typically as a result of processing a new
// transaction that uses it, the managed vars map will contain "Something" as a key and the
// value of managedVarSomething will be stored in noms on the next call to MarshalNoms().
// Until then, all new managedVar fields will retain their "zero" values.

var holdStructTemplate nt.StructTemplate

func init() {
	holdStructTemplate = nt.MakeStructTemplate("Hold", []string{
		"Expiry",
		"HasExpiry",
		"HasStake",
		"Qty",
		"Stake",
		"Txhash",
	})
}

// MarshalNoms implements noms/go/marshal.Marshaler
func (x Hold) MarshalNoms(vrw nt.ValueReadWriter) (holdValue nt.Value, err error) {
	// x.Qty (math.Ndau->*ast.SelectorExpr) is primitive: true

	// x.Expiry (*math.Timestamp->*ast.StarExpr) is primitive: false
	// template decompose: x.Expiry (*math.Timestamp->*ast.StarExpr)
	// template pointer:  x.Expiry
	var expiryUnptr nt.Value
	if x.Expiry == nil {
		expiryUnptr = util.Int(0).NomsValue()
	} else {
		// template decompose: (*x.Expiry) (math.Timestamp->*ast.SelectorExpr)
		expiryUnptr = util.Int((*x.Expiry)).NomsValue()
	}

	// x.Txhash (string->*ast.Ident) is primitive: true

	// x.Stake (*StakeData->*ast.StarExpr) is primitive: false
	// template decompose: x.Stake (*StakeData->*ast.StarExpr)
	// template pointer:  x.Stake
	var stakeUnptr nt.Value
	if x.Stake == nil {
		stakeUnptr = nt.Bool(false)
	} else {
		// template decompose: (*x.Stake) (StakeData->*ast.Ident)
		// template nomsmarshaler: (*x.Stake)
		stakeValue, err := (*x.Stake).MarshalNoms(vrw)
		if err != nil {
			return nil, errors.Wrap(err, "Hold.MarshalNoms->Stake.MarshalNoms")
		}
		stakeUnptr = stakeValue
	}

	values := []nt.Value{
		// x.Expiry (*math.Timestamp)
		expiryUnptr,
		// x.HasExpiry (bool)
		nt.Bool(x.Expiry != nil),
		// x.HasStake (bool)
		nt.Bool(x.Stake != nil),
		// x.Qty (math.Ndau)
		util.Int(x.Qty).NomsValue(),
		// x.Stake (*StakeData)
		stakeUnptr,
		// x.Txhash (string)
		nt.String(x.Txhash),
	}

	return holdStructTemplate.NewStruct(values), nil
}

var _ marshal.Marshaler = (*Hold)(nil)

// UnmarshalNoms implements noms/go/marshal.Unmarshaler
//
// This method makes no attempt to zeroize the provided struct; it simply
// overwrites fields as they are found.
func (x *Hold) UnmarshalNoms(value nt.Value) (err error) {
	vs, ok := value.(nt.Struct)
	if !ok {
		return fmt.Errorf(
			"Hold.UnmarshalNoms expected a nt.Value; found %s",
			reflect.TypeOf(value),
		)
	}

	// noms Struct.MaybeGet isn't efficient: it iterates over all fields of
	// the struct until it finds one whose name happens to match the one sought.
	// It's better to iterate once over the struct and set the fields of the
	// target struct in arbitrary order.
	vs.IterFields(func(name string, value nt.Value) {
		if err == nil {
			switch name {
			// x.Qty (math.Ndau->*ast.SelectorExpr) is primitive: true
			case "Qty":
				// template u_decompose: x.Qty (math.Ndau->*ast.SelectorExpr)
				// template u_primitive: x.Qty
				var qtyValue util.Int
				qtyValue, err = util.IntFrom(value)
				if err != nil {
					err = errors.Wrap(err, "Hold.UnmarshalNoms->Qty")
					return
				}
				qtyTyped := math.Ndau(qtyValue)

				x.Qty = qtyTyped
			// x.Expiry (*math.Timestamp->*ast.StarExpr) is primitive: false
			case "Expiry":
				// template u_decompose: x.Expiry (*math.Timestamp->*ast.StarExpr)
				// template u_pointer:  x.Expiry
				if hasExpiryValue, ok := vs.MaybeGet("HasExpiry"); ok {
					if hasExpiry, ok := hasExpiryValue.(nt.Bool); ok {
						if !hasExpiry {
							return
						}
					} else {
						err = fmt.Errorf(
							"Hold.UnmarshalNoms expected HasExpiry to be a nt.Bool; found %s",
							reflect.TypeOf(hasExpiryValue),
						)
						return
					}
				} else {
					err = fmt.Errorf(
						"Hold.UnmarshalNoms->Expiry is a pointer, so expected a HasExpiry field: not found",
					)
					return
				}

				// template u_decompose: x.Expiry (math.Timestamp->*ast.SelectorExpr)
				// template u_primitive: x.Expiry
				var expiryValue util.Int
				expiryValue, err = util.IntFrom(value)
				if err != nil {
					err = errors.Wrap(err, "Hold.UnmarshalNoms->Expiry")
					return
				}
				expiryTyped := math.Timestamp(expiryValue)

				x.Expiry = &expiryTyped
			// x.Txhash (string->*ast.Ident) is primitive: true
			case "Txhash":
				// template u_decompose: x.Txhash (string->*ast.Ident)
				// template u_primitive: x.Txhash
				txhashValue, ok := value.(nt.String)
				if !ok {
					err = fmt.Errorf(
						"Hold.UnmarshalNoms expected value to be a nt.String; found %s",
						reflect.TypeOf(value),
					)
				}
				txhashTyped := string(txhashValue)

				x.Txhash = txhashTyped
			// x.Stake (*StakeData->*ast.StarExpr) is primitive: false
			case "Stake":
				// template u_decompose: x.Stake (*StakeData->*ast.StarExpr)
				// template u_pointer:  x.Stake
				if hasStakeValue, ok := vs.MaybeGet("HasStake"); ok {
					if hasStake, ok := hasStakeValue.(nt.Bool); ok {
						if !hasStake {
							return
						}
					} else {
						err = fmt.Errorf(
							"Hold.UnmarshalNoms expected HasStake to be a nt.Bool; found %s",
							reflect.TypeOf(hasStakeValue),
						)
						return
					}
				} else {
					err = fmt.Errorf(
						"Hold.UnmarshalNoms->Stake is a pointer, so expected a HasStake field: not found",
					)
					return
				}

				// template u_decompose: x.Stake (StakeData->*ast.Ident)
				// template u_nomsmarshaler: x.Stake
				var stakeInstance StakeData
				err = stakeInstance.UnmarshalNoms(value)
				err = errors.Wrap(err, "Hold.UnmarshalNoms->Stake")

				x.Stake = &stakeInstance
			}
		}
	})
	return
}

var _ marshal.Unmarshaler = (*Hold)(nil)
