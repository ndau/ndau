package backing

import (
	"fmt"
	"reflect"
	"sort"

	"github.com/attic-labs/noms/go/marshal"
	nt "github.com/attic-labs/noms/go/types"
	"github.com/oneiro-ndev/ndaumath/pkg/address"
	math "github.com/oneiro-ndev/ndaumath/pkg/types"
	util "github.com/oneiro-ndev/noms-util"
	"github.com/pkg/errors"
)

// this code generated by github.com/oneiro-ndev/generator/cmd/nomsify
// DO NOT EDIT

var stakeDataStructTemplate nt.StructTemplate

func init() {
	stakeDataStructTemplate = nt.MakeStructTemplate("StakeData", []string{
		"Point",
		"RulesAcct",
		"StakeTo",
	})
}

// MarshalNoms implements noms/go/marshal.Marshaler
func (x StakeData) MarshalNoms(vrw nt.ValueReadWriter) (stakeDataValue nt.Value, err error) {
	// x.Point (math.Timestamp->*ast.SelectorExpr) is primitive: true

	// x.RulesAcct (address.Address->*ast.SelectorExpr) is primitive: false

	// template decompose: x.RulesAcct (address.Address->*ast.SelectorExpr)
	// template textmarshaler: x.RulesAcct
	rulesAcctString, err := x.RulesAcct.MarshalText()
	if err != nil {
		return nil, errors.Wrap(err, "StakeData.MarshalNoms->RulesAcct.MarshalText")
	}

	// x.StakeTo (address.Address->*ast.SelectorExpr) is primitive: false

	// template decompose: x.StakeTo (address.Address->*ast.SelectorExpr)
	// template textmarshaler: x.StakeTo
	stakeToString, err := x.StakeTo.MarshalText()
	if err != nil {
		return nil, errors.Wrap(err, "StakeData.MarshalNoms->StakeTo.MarshalText")
	}

	return stakeDataStructTemplate.NewStruct([]nt.Value{
		// x.Point (math.Timestamp)

		util.Int(x.Point).NomsValue(),
		// x.RulesAcct (address.Address)
		nt.String(rulesAcctString),
		// x.StakeTo (address.Address)
		nt.String(stakeToString),
	}), nil
}

var _ marshal.Marshaler = (*StakeData)(nil)

// UnmarshalNoms implements noms/go/marshal.Unmarshaler
//
// This method makes no attempt to zeroize the provided struct; it simply
// overwrites fields as they are found.
func (x *StakeData) UnmarshalNoms(value nt.Value) (err error) {
	vs, ok := value.(nt.Struct)
	if !ok {
		return fmt.Errorf(
			"StakeData.UnmarshalNoms expected a nt.Value; found %s",
			reflect.TypeOf(value),
		)
	}

	// noms Struct.MaybeGet isn't efficient: it iterates over all fields of
	// the struct until it finds one whose name happens to match the one sought.
	// It's better to iterate once over the struct and set the fields of the
	// target struct in arbitrary order.
	vs.IterFields(func(name string, value nt.Value) {
		if err == nil {
			switch name {
			// x.Point (math.Timestamp->*ast.SelectorExpr) is primitive: true
			case "Point":
				// template u_decompose: x.Point (math.Timestamp->*ast.SelectorExpr)
				// template u_primitive: x.Point
				var pointValue util.Int
				pointValue, err = util.IntFrom(value)
				if err != nil {
					err = errors.Wrap(err, "StakeData.UnmarshalNoms->Point")
					return
				}
				pointTyped := math.Timestamp(pointValue)

				x.Point = pointTyped
			// x.RulesAcct (address.Address->*ast.SelectorExpr) is primitive: false
			case "RulesAcct":
				// template u_decompose: x.RulesAcct (address.Address->*ast.SelectorExpr)
				// template u_textmarshaler: x.RulesAcct
				var rulesAcctValue address.Address
				if rulesAcctString, ok := value.(nt.String); ok {
					err = rulesAcctValue.UnmarshalText([]byte(rulesAcctString))
				} else {
					err = fmt.Errorf(
						"StakeData.UnmarshalNoms expected value to be a nt.String; found %s",
						reflect.ValueOf(value).Type(),
					)
				}

				x.RulesAcct = rulesAcctValue
			// x.StakeTo (address.Address->*ast.SelectorExpr) is primitive: false
			case "StakeTo":
				// template u_decompose: x.StakeTo (address.Address->*ast.SelectorExpr)
				// template u_textmarshaler: x.StakeTo
				var stakeToValue address.Address
				if stakeToString, ok := value.(nt.String); ok {
					err = stakeToValue.UnmarshalText([]byte(stakeToString))
				} else {
					err = fmt.Errorf(
						"StakeData.UnmarshalNoms expected value to be a nt.String; found %s",
						reflect.ValueOf(value).Type(),
					)
				}

				x.StakeTo = stakeToValue
			}
		}
	})
	return
}

var _ marshal.Unmarshaler = (*StakeData)(nil)

var stakeRulesStructTemplate nt.StructTemplate

func init() {
	stakeRulesStructTemplate = nt.MakeStructTemplate("StakeRules", []string{
		"Inbound",
		"Script",
	})
}

// MarshalNoms implements noms/go/marshal.Marshaler
func (x StakeRules) MarshalNoms(vrw nt.ValueReadWriter) (stakeRulesValue nt.Value, err error) {
	// x.Script ([]byte->*ast.ArrayType) is primitive: true

	// x.Inbound (map[string]struct{}->*ast.MapType) is primitive: false

	// template decompose: x.Inbound (map[string]struct{}->*ast.MapType)
	// template set:  x.Inbound
	inboundItems := make([]nt.Value, 0, len(x.Inbound))
	if len(x.Inbound) > 0 {
		// We need to iterate the set in sorted order, so build []string and sort it first
		inboundSorted := make([]string, 0, len(x.Inbound))
		for inboundItem := range x.Inbound {
			inboundSorted = append(inboundSorted, inboundItem)
		}
		sort.Sort(sort.StringSlice(inboundSorted))
		for _, inboundItem := range inboundSorted {
			inboundItems = append(
				inboundItems,
				nt.String(inboundItem),
			)
		}
	}

	return stakeRulesStructTemplate.NewStruct([]nt.Value{
		// x.Inbound (map[string]struct{})
		nt.NewSet(vrw, inboundItems...),
		// x.Script ([]byte)

		nt.String(x.Script),
	}), nil
}

var _ marshal.Marshaler = (*StakeRules)(nil)

// UnmarshalNoms implements noms/go/marshal.Unmarshaler
//
// This method makes no attempt to zeroize the provided struct; it simply
// overwrites fields as they are found.
func (x *StakeRules) UnmarshalNoms(value nt.Value) (err error) {
	vs, ok := value.(nt.Struct)
	if !ok {
		return fmt.Errorf(
			"StakeRules.UnmarshalNoms expected a nt.Value; found %s",
			reflect.TypeOf(value),
		)
	}

	// noms Struct.MaybeGet isn't efficient: it iterates over all fields of
	// the struct until it finds one whose name happens to match the one sought.
	// It's better to iterate once over the struct and set the fields of the
	// target struct in arbitrary order.
	vs.IterFields(func(name string, value nt.Value) {
		if err == nil {
			switch name {
			// x.Script ([]byte->*ast.ArrayType) is primitive: true
			case "Script":
				// template u_decompose: x.Script ([]byte->*ast.ArrayType)
				// template u_primitive: x.Script
				scriptValue, ok := value.(nt.String)
				if !ok {
					err = fmt.Errorf(
						"StakeRules.UnmarshalNoms expected value to be a nt.String; found %s",
						reflect.TypeOf(value),
					)
				}
				scriptTyped := []byte(scriptValue)

				x.Script = scriptTyped
			// x.Inbound (map[string]struct{}->*ast.MapType) is primitive: false
			case "Inbound":
				// template u_decompose: x.Inbound (map[string]struct{}->*ast.MapType)
				// template u_set: x.Inbound
				inboundGoSet := make(map[string]struct{})
				if inboundSet, ok := value.(nt.Set); ok {
					inboundSet.Iter(func(inboundItem nt.Value) (stop bool) {
						if inboundItemString, ok := inboundItem.(nt.String); ok {
							inboundGoSet[string(inboundItemString)] = struct{}{}
						} else {
							err = fmt.Errorf(
								"StakeRules.AccountData.UnmarshalNoms expected InboundItem to be a nt.String; found %s",
								reflect.TypeOf(value),
							)
						}
						return err != nil
					})
				} else {
					err = fmt.Errorf(
						"StakeRules.AccountData.UnmarshalNoms expected Inbound to be a nt.Set; found %s",
						reflect.TypeOf(value),
					)
				}

				x.Inbound = inboundGoSet
			}
		}
	})
	return
}

var _ marshal.Unmarshaler = (*StakeRules)(nil)
