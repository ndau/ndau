package backing

import (
	"fmt"
	"reflect"

	"github.com/attic-labs/noms/go/marshal"
	nt "github.com/attic-labs/noms/go/types"
	"github.com/oneiro-ndev/ndaumath/pkg/eai"
	math "github.com/oneiro-ndev/ndaumath/pkg/types"
	util "github.com/oneiro-ndev/noms-util"
	"github.com/pkg/errors"
)

// this code generated by github.com/oneiro-ndev/generator/cmd/nomsify
// DO NOT EDIT

var lockStructTemplate nt.StructTemplate

func init() {
	lockStructTemplate = nt.MakeStructTemplate("Lock", []string{
		"Bonus",
		"HasUnlocksOn",
		"NoticePeriod",
		"UnlocksOn",
	})
}

// MarshalNoms implements noms/go/marshal.Marshaler
func (x Lock) MarshalNoms(vrw nt.ValueReadWriter) (lockValue nt.Value, err error) {
	// x.NoticePeriod (math.Duration->*ast.SelectorExpr) is primitive: true

	// x.UnlocksOn (*math.Timestamp->*ast.StarExpr) is primitive: false

	// template decompose: x.UnlocksOn (*math.Timestamp->*ast.StarExpr)
	// template pointer:  x.UnlocksOn
	var unlocksOnUnptr nt.Value
	if x.UnlocksOn == nil {
		unlocksOnUnptr = util.Int(0).NomsValue()
	} else {

		// template decompose: (*x.UnlocksOn) (math.Timestamp->*ast.SelectorExpr)

		unlocksOnUnptr = util.Int((*x.UnlocksOn)).NomsValue()
	}

	// x.Bonus (eai.Rate->*ast.SelectorExpr) is primitive: true

	return lockStructTemplate.NewStruct([]nt.Value{
		// x.Bonus (eai.Rate)

		util.Int(x.Bonus).NomsValue(),
		// x.HasUnlocksOn (bool)

		nt.Bool(x.UnlocksOn != nil),
		// x.NoticePeriod (math.Duration)

		util.Int(x.NoticePeriod).NomsValue(),
		// x.UnlocksOn (*math.Timestamp)
		unlocksOnUnptr,
	}), nil
}

var _ marshal.Marshaler = (*Lock)(nil)

// UnmarshalNoms implements noms/go/marshal.Unmarshaler
//
// This method makes no attempt to zeroize the provided struct; it simply
// overwrites fields as they are found.
func (x *Lock) UnmarshalNoms(value nt.Value) (err error) {
	vs, ok := value.(nt.Struct)
	if !ok {
		return fmt.Errorf(
			"Lock.UnmarshalNoms expected a nt.Value; found %s",
			reflect.TypeOf(value),
		)
	}

	// noms Struct.MaybeGet isn't efficient: it iterates over all fields of
	// the struct until it finds one whose name happens to match the one sought.
	// It's better to iterate once over the struct and set the fields of the
	// target struct in arbitrary order.
	vs.IterFields(func(name string, value nt.Value) {
		if err == nil {
			switch name {
			// x.NoticePeriod (math.Duration->*ast.SelectorExpr) is primitive: true
			case "NoticePeriod":
				// template u_decompose: x.NoticePeriod (math.Duration->*ast.SelectorExpr)
				// template u_primitive: x.NoticePeriod
				var noticePeriodValue util.Int
				noticePeriodValue, err = util.IntFrom(value)
				if err != nil {
					err = errors.Wrap(err, "Lock.UnmarshalNoms->NoticePeriod")
					return
				}
				noticePeriodTyped := math.Duration(noticePeriodValue)

				x.NoticePeriod = noticePeriodTyped

			// x.UnlocksOn (*math.Timestamp->*ast.StarExpr) is primitive: false
			case "UnlocksOn":
				// template u_decompose: x.UnlocksOn (*math.Timestamp->*ast.StarExpr)
				// template u_pointer:  x.UnlocksOn
				if hasUnlocksOnValue, ok := vs.MaybeGet("HasUnlocksOn"); ok {
					if hasUnlocksOn, ok := hasUnlocksOnValue.(nt.Bool); ok {
						if !hasUnlocksOn {
							return
						}
					} else {
						err = fmt.Errorf(
							"Lock.UnmarshalNoms expected HasUnlocksOn to be a nt.Bool; found %s",
							reflect.TypeOf(hasUnlocksOnValue),
						)
						return
					}
				} else {
					err = fmt.Errorf(
						"Lock.UnmarshalNoms->UnlocksOn is a pointer, so expected a HasUnlocksOn field: not found",
					)
					return
				}

				// template u_decompose: x.UnlocksOn (math.Timestamp->*ast.SelectorExpr)
				// template u_primitive: x.UnlocksOn
				var unlocksOnValue util.Int
				unlocksOnValue, err = util.IntFrom(value)
				if err != nil {
					err = errors.Wrap(err, "Lock.UnmarshalNoms->UnlocksOn")
					return
				}
				unlocksOnTyped := math.Timestamp(unlocksOnValue)

				x.UnlocksOn = &unlocksOnTyped

			// x.Bonus (eai.Rate->*ast.SelectorExpr) is primitive: true
			case "Bonus":
				// template u_decompose: x.Bonus (eai.Rate->*ast.SelectorExpr)
				// template u_primitive: x.Bonus
				var bonusValue util.Int
				bonusValue, err = util.IntFrom(value)
				if err != nil {
					err = errors.Wrap(err, "Lock.UnmarshalNoms->Bonus")
					return
				}
				bonusTyped := eai.Rate(bonusValue)

				x.Bonus = bonusTyped

			}
		}
	})
	return
}

var _ marshal.Unmarshaler = (*Lock)(nil)
