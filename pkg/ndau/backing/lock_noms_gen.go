package backing

// this code generated by github.com/ndau/generator/cmd/nomsify -- DO NOT EDIT

// ----- ---- --- -- -
// Copyright 2019 Oneiro NA, Inc. All Rights Reserved.
//
// Licensed under the Apache License 2.0 (the "License").  You may not use
// this file except in compliance with the License.  You can obtain a copy
// in the file LICENSE in the source distribution or at
// https://www.apache.org/licenses/LICENSE-2.0.txt
// - -- --- ---- -----

import (
	"fmt"
	"reflect"

	"github.com/ndau/noms/go/marshal"
	nt "github.com/ndau/noms/go/types"
	"github.com/ndau/ndaumath/pkg/eai"
	math "github.com/ndau/ndaumath/pkg/types"
	util "github.com/ndau/noms-util"
	"github.com/pkg/errors"
)

// Adding new fields to a nomsify-able struct:
//
// Managed vars are useful for adding new fields that are marshaled to noms only after they're
// first set, so that app hashes aren't affected until the new fields are actually needed.
//
// A managed vars map is a hash map whose keys are managed variable names.
// The `managedVars map[string]struct{}` field must be manually declared in the struct.
//
// Declare new fields using the "managedVar" prefix.  e.g. `managedVarSomething SomeType`.
// GetSomething() and SetSomething() are generated for public access to the new field.
//
// Once SetSomething() is called for the first time, typically as a result of processing a new
// transaction that uses it, the managed vars map will contain "Something" as a key and the
// value of managedVarSomething will be stored in noms on the next call to MarshalNoms().
// Until then, all new managedVar fields will retain their "zero" values.

var lockStructTemplate nt.StructTemplate

func init() {
	lockStructTemplate = nt.MakeStructTemplate("Lock", []string{
		"Bonus",
		"HasUnlocksOn",
		"NoticePeriod",
		"UnlocksOn",
	})
}

// MarshalNoms implements noms/go/marshal.Marshaler
func (x Lock) MarshalNoms(vrw nt.ValueReadWriter) (lockValue nt.Value, err error) {
	// x.NoticePeriod (math.Duration->*ast.SelectorExpr) is primitive: true

	// x.UnlocksOn (*math.Timestamp->*ast.StarExpr) is primitive: false
	// template decompose: x.UnlocksOn (*math.Timestamp->*ast.StarExpr)
	// template pointer:  x.UnlocksOn
	var unlocksOnUnptr nt.Value
	if x.UnlocksOn == nil {
		unlocksOnUnptr = util.Int(0).NomsValue()
	} else {
		// template decompose: (*x.UnlocksOn) (math.Timestamp->*ast.SelectorExpr)
		unlocksOnUnptr = util.Int((*x.UnlocksOn)).NomsValue()
	}

	// x.Bonus (eai.Rate->*ast.SelectorExpr) is primitive: true

	values := []nt.Value{
		// x.Bonus (eai.Rate)
		util.Int(x.Bonus).NomsValue(),
		// x.HasUnlocksOn (bool)
		nt.Bool(x.UnlocksOn != nil),
		// x.NoticePeriod (math.Duration)
		util.Int(x.NoticePeriod).NomsValue(),
		// x.UnlocksOn (*math.Timestamp)
		unlocksOnUnptr,
	}

	return lockStructTemplate.NewStruct(values), nil
}

var _ marshal.Marshaler = (*Lock)(nil)

// UnmarshalNoms implements noms/go/marshal.Unmarshaler
//
// This method makes no attempt to zeroize the provided struct; it simply
// overwrites fields as they are found.
func (x *Lock) UnmarshalNoms(value nt.Value) (err error) {
	vs, ok := value.(nt.Struct)
	if !ok {
		return fmt.Errorf(
			"Lock.UnmarshalNoms expected a nt.Value; found %s",
			reflect.TypeOf(value),
		)
	}

	// noms Struct.MaybeGet isn't efficient: it iterates over all fields of
	// the struct until it finds one whose name happens to match the one sought.
	// It's better to iterate once over the struct and set the fields of the
	// target struct in arbitrary order.
	vs.IterFields(func(name string, value nt.Value) (stop bool) {
		switch name {
		// x.NoticePeriod (math.Duration->*ast.SelectorExpr) is primitive: true
		case "NoticePeriod":
			// template u_decompose: x.NoticePeriod (math.Duration->*ast.SelectorExpr)
			// template u_primitive: x.NoticePeriod
			var noticePeriodValue util.Int
			noticePeriodValue, err = util.IntFrom(value)
			if err != nil {
				err = errors.Wrap(err, "Lock.UnmarshalNoms->NoticePeriod")
				return
			}
			noticePeriodTyped := math.Duration(noticePeriodValue)

			x.NoticePeriod = noticePeriodTyped
		// x.UnlocksOn (*math.Timestamp->*ast.StarExpr) is primitive: false
		case "UnlocksOn":
			// template u_decompose: x.UnlocksOn (*math.Timestamp->*ast.StarExpr)
			// template u_pointer:  x.UnlocksOn
			if hasUnlocksOnValue, ok := vs.MaybeGet("HasUnlocksOn"); ok {
				if hasUnlocksOn, ok := hasUnlocksOnValue.(nt.Bool); ok {
					if !hasUnlocksOn {
						return
					}
				} else {
					err = fmt.Errorf(
						"Lock.UnmarshalNoms expected HasUnlocksOn to be a nt.Bool; found %s",
						reflect.TypeOf(hasUnlocksOnValue),
					)
					return
				}
			} else {
				err = fmt.Errorf(
					"Lock.UnmarshalNoms->UnlocksOn is a pointer, so expected a HasUnlocksOn field: not found",
				)
				return
			}

			// template u_decompose: x.UnlocksOn (math.Timestamp->*ast.SelectorExpr)
			// template u_primitive: x.UnlocksOn
			var unlocksOnValue util.Int
			unlocksOnValue, err = util.IntFrom(value)
			if err != nil {
				err = errors.Wrap(err, "Lock.UnmarshalNoms->UnlocksOn")
				return
			}
			unlocksOnTyped := math.Timestamp(unlocksOnValue)

			x.UnlocksOn = &unlocksOnTyped
		// x.Bonus (eai.Rate->*ast.SelectorExpr) is primitive: true
		case "Bonus":
			// template u_decompose: x.Bonus (eai.Rate->*ast.SelectorExpr)
			// template u_primitive: x.Bonus
			var bonusValue util.Int
			bonusValue, err = util.IntFrom(value)
			if err != nil {
				err = errors.Wrap(err, "Lock.UnmarshalNoms->Bonus")
				return
			}
			bonusTyped := eai.Rate(bonusValue)

			x.Bonus = bonusTyped
		}
		stop = err != nil
		return
	})
	return
}

var _ marshal.Unmarshaler = (*Lock)(nil)
